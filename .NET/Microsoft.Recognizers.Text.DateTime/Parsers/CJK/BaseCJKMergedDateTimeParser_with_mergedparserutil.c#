using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Microsoft.Recognizers.Text.Utilities;
using DateObject = System.DateTime;

namespace Microsoft.Recognizers.Text.DateTime
{
    public class BaseCJKMergedDateTimeParser : IDateTimeParser
    {
        public const string ParserTypeName = "datetimeV2";

        private readonly ICJKMergedParserConfiguration config;

        public BaseCJKMergedDateTimeParser(ICJKMergedParserConfiguration configuration)
        {
            config = configuration;
        }

        public List<DateTimeParseResult> FilterResults(string query, List<DateTimeParseResult> candidateResults)
        {
            return candidateResults;
        }

        public ParseResult Parse(ExtractResult er)
        {
            return Parse(er, DateObject.Now);
        }

        public DateTimeParseResult Parse(ExtractResult er, DateObject refTime)
        {
            var referenceTime = refTime;
            DateTimeParseResult pr;

            // push, save teh MOD string
            var hasInclusiveModifier = false;
            bool hasBefore = false, hasAfter = false, hasUntil = false, hasSince = false, hasEqual = false;
            string modStr = string.Empty, modStrPrefix = string.Empty, modStrSuffix = string.Empty;
            if (er.Metadata != null)
            {
                var beforeMatch = config.BeforeRegex.MatchEnd(er.Text, trim: true);
                var afterMatch = config.AfterRegex.MatchEnd(er.Text, trim: true);
                var untilMatch = config.UntilRegex.MatchBegin(er.Text, trim: true);
                var sinceMatchPrefix = config.SincePrefixRegex.MatchBegin(er.Text, trim: true);
                var sinceMatchSuffix = config.SinceSuffixRegex.MatchEnd(er.Text, trim: true);
                var equalMatch = config.EqualRegex.MatchBegin(er.Text, trim: true);

                if (beforeMatch.Success && !MergedParserUtil.IsDurationWithAgoAndLater(er))
                {
                    hasBefore = true;
                    er.Length -= beforeMatch.Length;
                    er.Text = er.Text.Substring(0, er.Length ?? 0);
                    modStr = beforeMatch.Value;

                    if (!string.IsNullOrEmpty(beforeMatch.Groups[Constants.IncludeGroupName].Value))
                    {
                        hasInclusiveModifier = true;
                    }
                }
                else if (afterMatch.Success && !MergedParserUtil.IsDurationWithAgoAndLater(er))
                {
                    hasAfter = true;
                    er.Length -= afterMatch.Length;
                    er.Text = er.Text.Substring(0, er.Length ?? 0);
                    modStr = afterMatch.Value;

                    if (!string.IsNullOrEmpty(afterMatch.Groups[Constants.IncludeGroupName].Value))
                    {
                        hasInclusiveModifier = true;
                    }
                }
                else if (untilMatch.Success)
                {
                    hasUntil = true;
                    er.Start += untilMatch.Length;
                    er.Length -= untilMatch.Length;
                    er.Text = er.Text.Substring(untilMatch.Length);
                    modStr = untilMatch.Value;
                }
                else if (equalMatch.Success)
                {
                    hasEqual = true;
                    er.Start += equalMatch.Length;
                    er.Length -= equalMatch.Length;
                    er.Text = er.Text.Substring(equalMatch.Length);
                    modStr = equalMatch.Value;
                }
                else
                {
                    if (sinceMatchPrefix.Success)
                    {
                        hasSince = true;
                        er.Start += sinceMatchPrefix.Length;
                        er.Length -= sinceMatchPrefix.Length;
                        er.Text = er.Text.Substring(sinceMatchPrefix.Length);
                        modStrPrefix = sinceMatchPrefix.Value;
                    }

                    if (sinceMatchSuffix.Success)
                    {
                        hasSince = true;
                        er.Length -= sinceMatchSuffix.Length;
                        er.Text = er.Text.Substring(0, er.Length ?? 0);
                        modStrSuffix = sinceMatchSuffix.Value;
                    }
                }
            }

            if (er.Type.Equals(Constants.SYS_DATETIME_DATE, StringComparison.Ordinal))
            {
                pr = config.DateParser.Parse(er, referenceTime);
                if (pr.Value == null)
                {
                    pr = config.HolidayParser.Parse(er, referenceTime);
                }
            }
            else if (er.Type.Equals(Constants.SYS_DATETIME_TIME, StringComparison.Ordinal))
            {
                pr = config.TimeParser.Parse(er, referenceTime);
            }
            else if (er.Type.Equals(Constants.SYS_DATETIME_DATETIME, StringComparison.Ordinal))
            {
                pr = config.DateTimeParser.Parse(er, referenceTime);
            }
            else if (er.Type.Equals(Constants.SYS_DATETIME_DATEPERIOD, StringComparison.Ordinal))
            {
                pr = config.DatePeriodParser.Parse(er, referenceTime);
            }
            else if (er.Type.Equals(Constants.SYS_DATETIME_TIMEPERIOD, StringComparison.Ordinal))
            {
                pr = config.TimePeriodParser.Parse(er, referenceTime);
            }
            else if (er.Type.Equals(Constants.SYS_DATETIME_DATETIMEPERIOD, StringComparison.Ordinal))
            {
                pr = config.DateTimePeriodParser.Parse(er, referenceTime);
            }
            else if (er.Type.Equals(Constants.SYS_DATETIME_DURATION, StringComparison.Ordinal))
            {
                pr = config.DurationParser.Parse(er, referenceTime);
            }
            else if (er.Type.Equals(Constants.SYS_DATETIME_SET, StringComparison.Ordinal))
            {
                pr = config.SetParser.Parse(er, referenceTime);
            }
            else
            {
                return null;
            }

            // pop, restore the MOD string
            if (hasBefore)
            {
                pr.Length += modStr.Length;
                pr.Text = pr.Text + modStr;
                var val = (DateTimeResolutionResult)pr.Value;

                val.Mod = MergedParserUtil.CombineMod(val.Mod, !hasInclusiveModifier ? Constants.BEFORE_MOD : Constants.UNTIL_MOD);

                pr.Value = val;
            }

            if (hasAfter)
            {
                pr.Length += modStr.Length;
                pr.Text = pr.Text + modStr;
                var val = (DateTimeResolutionResult)pr.Value;

                val.Mod = MergedParserUtil.CombineMod(val.Mod, !hasInclusiveModifier ? Constants.AFTER_MOD : Constants.SINCE_MOD);

                pr.Value = val;
            }

            if (hasUntil)
            {
                pr.Length += modStr.Length;
                pr.Start -= modStr.Length;
                pr.Text = modStr + pr.Text;
                var val = (DateTimeResolutionResult)pr.Value;
                val.Mod = Constants.BEFORE_MOD;
                pr.Value = val;
                hasBefore = true;
            }

            if (hasSince)
            {
                pr.Length += modStrPrefix.Length + modStrSuffix.Length;
                pr.Start -= modStrPrefix.Length;
                pr.Text = modStrPrefix + pr.Text + modStrSuffix;
                var val = (DateTimeResolutionResult)pr.Value;
                val.Mod = Constants.SINCE_MOD;
                pr.Value = val;
            }

            if (hasEqual)
            {
                pr.Length += modStr.Length;
                pr.Start -= modStr.Length;
                pr.Text = modStr + pr.Text;
            }

            var hasRangeChangingMod = hasBefore || hasAfter || hasSince;
            if (pr.Value != null)
            {
                ((DateTimeResolutionResult)pr.Value).HasRangeChangingMod = hasRangeChangingMod;
            }

            pr = MergedParserUtil.SetParseResult(pr, ParserTypeName, hasRangeChangingMod, this.config);

            /*pr.Value = MergedParserUtil.DateTimeResolution(pr, hasRangeChangingMod, this.config);

            // change the type at last for the after or before mode
            pr.Type = $"{ParserTypeName}.{MergedParserUtil.DetermineDateTimeType(er.Type, hasRangeChangingMod, this.config)}";*/

            return pr;
        }
    }
}